from math import sqrt

from base_pong.ball import Ball
from base_pong.drawable_objects import GameObject, Ellipse
from base_pong.equations import Point, LineSegment
from base_pong.path import Path
from base_pong.utility_classes import HistoryKeeper, Range
from base_pong.important_variables import (
    screen_height,
    screen_length
)
from base_pong.utility_functions import get_rightmost_object, get_leftmost_object, max_value
from base_pong.utility_functions import lists_share_an_item, solve_quadratic, min_value, is_within_range
from base_pong.velocity_calculator import VelocityCalculator

class CollisionData:
    """Stores all the data for collisions"""
    is_collision = False
    is_moving_collision = False
    is_right_collision = False
    object_xy = None

    def __init__(self, is_collision, is_moving_collision, is_right_collision, object_xy):
        self.is_collision, self.is_moving_collision = is_collision, is_moving_collision
        self.is_right_collision, self.object_xy = is_right_collision, object_xy


class CollisionsUtilityFunctions:
    def get_object_xy(current_object, prev_object, time):
        """returns: Point; the object's x and y at that time"""

        x_line = LineSegment(Point(0, prev_object.x_coordinate), Point(VelocityCalculator.time, current_object.x_coordinate))
        y_line = LineSegment(Point(0, prev_object.y_coordinate), Point(VelocityCalculator.time, current_object.y_coordinate))
        return Point(x_line.get_y_coordinate(time), y_line.get_y_coordinate(time))

    def get_is_right_collision(object1_x_displacement, object2_x_displacement):
        """ summary: uses the displacements to find out if it is a right collision

            params:
                object1_x_displacement: double; the displacement of the object in question to see if it hit/got hit object2 from the right
                object2_x_displacement: double; the displacement of the other object

            returns: boolean; if object1 hit/ got hit by object2 from the right
        """
        is_right_collision = False

        object1_x_distance_traveled = abs(object1_x_displacement)
        object2_x_distance_traveled = abs(object2_x_displacement)

        if object2_x_distance_traveled >= object1_x_distance_traveled:
            # Since object2 traveled a greater distance its displacement matters more (if it goes leftwards into the ball
            # it would be a left collision and if it goes rightwards it would be a right collision)
            is_right_collision = object2_x_displacement > 0

        else:
            # Otherwise since object1 has traveled the greater distance the direction it goes matters most
            is_right_collision = object1_x_displacement < 0

        return is_right_collision

    def get_collision_data(object1, object2, collision_time, is_moving_collision):
        """returns: List of CollisionData; [object1 Collision Data, object2 Collision Data]"""

        is_collision = collision_time != -1

        prev_object1 = HistoryKeeper.get_last(object1.name)
        prev_object2 = HistoryKeeper.get_last(object2.name)
        object_xy = CollisionsUtilityFunctions.get_object_xy(prev_object1, object1, collision_time)

        object1_displacement = object1.x_coordinate - prev_object1.x_coordinate
        object2_displacement = object2.x_coordinate - prev_object2.x_coordinate
        is_right_collision = CollisionsUtilityFunctions.get_is_right_collision(object1_displacement, object2_displacement)
        # if type(object1) == Ball and is_collision:
        #     CollisionsUtilityFunctions.get_is_right_collision(object1_displacement, object2_displacement)
        return CollisionData(is_collision, is_moving_collision, is_right_collision, object_xy)

    def get_path_collision_time(object1_paths: Path, object2_paths: Path, object1_length, object2_length):
        """ summary: finds the time that object1 and object2 collide using their paths

            params:
                object1_paths: List of Path; [object1 x path, object1 right edge path]- the path of object1


            returns: List of Collision; [object1 CollisionData, object2 CollisionData]"""

        # TODO find what the times are
        x_line1, right_edge_line1, y_line1, bottom_line1 = object1_paths.get_lines(object1_length)
        x_line2, right_edge_line2, y_line2, bottom_line2 = object2_paths.get_lines(object2_length)

    def get_times_between(line: LineSegment, top_line: LineSegment, bottom_line: LineSegment):
        """returns: List of Range; the times that 'line' is between 'top_line' and 'bottom_line' NOTE: the lines must have
        time as their x coordinate and the coordinates (x, y, bottom, or right_edge) as the y coordinate"""

        is_between_lines = (line.start_point.y_coordinate >= bottom_line.start_point.y_coordinate and
                            line.start_point.y_coordinate <= top_line.start_point.y_coordinate)

        collision_times = []
        time1 = CollisionsUtilityFunctions.get_line_collision_point(line, top_line)
        time2 = CollisionsUtilityFunctions.get_line_collision_point(line, bottom_line)

        # Adding the time1 and time2 to collision_times if there was a collision: -1
        collision_times += [time1] if time1 != -1 else []
        collision_times += [time1] if time2 != -1 else []

        collision_times.sort()
        start_time = 0
        times = []
        for collision_time in collision_times:
            if is_between_lines:
                times.append(Range(start_time, collision_time))

            is_between_lines = not is_between_lines
            start_time = collision_time

        if is_between_lines:
            times.append(Range(start_time, VelocityCalculator.time))

        return times

    def get_moving_collision_time(moving_object_paths, stationary_object):
        """ summary: Calls is_line_ellipse_collision() or is_line_rectangle_collision()
                     depending on if the stationary object is elliptical or rectangular

            params:
                moving_object_path: Path; the moving object's path
                stationary_object: GameObject; the object that isn't moving

            returns: boolean; if the moving object's path collides with the stationary object
        """

        collision_time = float('inf')
        for path in moving_object_paths:
            for line in path.get_lines():
                time = None
                if type(stationary_object) == Ellipse:
                    time = CollisionsUtilityFunctions.get_line_ellipse_collision_time(stationary_object, line)

                # Assumes that if it isn't an ellipse it must be a rectangle
                else:
                    time = CollisionsUtilityFunctions.get_line_rectangle_collision_time(stationary_object, line)

                if time != -1 and time < collision_time:
                    collision_time = time

        return collision_time if collision_time != float('inf') else -1

    def get_line_rectangle_collision_time(rectangle: GameObject, line: LineSegment):
        """returns: Point; the point at which the rectangle and line collide (None if they don't collide)"""

        rectangle_lines = [
            LineSegment(Point(rectangle.x_coordinate, rectangle.y_coordinate), Point(rectangle.x_coordinate, rectangle.bottom)),
            LineSegment(Point(rectangle.x_coordinate, rectangle.bottom), Point(rectangle.right_edge, rectangle.bottom)),
            LineSegment(Point(rectangle.right_edge, rectangle.bottom), Point(rectangle.right_edge, rectangle.y_coordinate)),
            LineSegment(Point(rectangle.right_edge, rectangle.y_coordinate), Point(rectangle.x_coordinate, rectangle.y_coordinate))
        ]

        collision_time = float('inf')

        for rectangle_line in rectangle_lines:
            collision_point = CollisionsUtilityFunctions.get_line_collision_point(rectangle_line, line)
            if collision_point is not None:
                time = CollisionsUtilityFunctions.get_time_to_point(line, collision_point)
                collision_time = time if time < collision_time else collision_time

        return collision_time if collision_time != float('inf') else -1

    def get_smallest_time(line: LineSegment, points):
        """returns: double; the smallest amount of time it would take for the line to go from it starts to a point"""

        smallest_time = float('inf')
        for point in points:
            x_line = LineSegment(Point(0, line.start_point.x_coordinate), Point(VelocityCalculator.time, point.x_coordinate))

            time = x_line.get_x_coordinate(point.x_coordinate)

            if time < smallest_time:
                smallest_time = time

        return smallest_time if smallest_time != float('inf') else -1

    def get_line_ellipse_collision_time(ellipse: Ellipse, line: LineSegment):
        """returns: Point; the point at which the line and the ellipse collide (None if they don't collide)"""

        # I'm using c in place of b since I have two b's one from the ellipse and the other from the line
        h, k, a, c = ellipse.get_equation_variables()

        m, b = line.slope, line.y_intercept

        # See documentation.md for where these numbers came from
        # quadratic_a = -(pow(a, 2) * pow(c, 2) - (pow(a, 2) * pow(m, 2) + pow(c, 2)))
        # quadratic_b = -2 * (pow(a, 2) * (b - k) * m - pow(c, 2) * h)
        # quadratic_c = -pow(a, 2) * (pow(b, 2) - 2 * b * k + pow(k, 2)) - pow(c, 2) * pow(h, 2)
        quadratic_a = pow(a, 2) * pow(m, 2) + pow(c, 2)
        quadratic_b = 2 * (pow(a, 2) * (b - k) * m - pow(c, 2) * h)
        quadratic_c = pow(a, 2) * pow(b - k, 2) + pow(c, 2) * pow(h, 2) - pow(a, 2) * pow(c, 2)

        answers = solve_quadratic(quadratic_a, quadratic_b, quadratic_c)
        # The difference between supposed_collision_points and collision_points is that collision_points takes into account
        # That it is a line segment while supposed_collision_points doesn't
        supposed_collision_points = []
        collision_points = []
        # solve_quadratic returns False if it gets an imaginary number meaning there isn't a collision

        if answers is not None:
            x_coordinate1, x_coordinate2 = answers
            y_coordinate1, y_coordinate2 = line.get_y_coordinate(x_coordinate1), line.get_y_coordinate(x_coordinate2)
            supposed_collision_points = [Point(x_coordinate1, y_coordinate1), Point(x_coordinate2, y_coordinate2)]

        if answers is not None and line.contains_point(supposed_collision_points[0], 1):
            collision_points.append(supposed_collision_points[0])

        if answers is not None and line.contains_point(supposed_collision_points[1], 1):
            collision_points.append(supposed_collision_points[1])

        return CollisionsUtilityFunctions.get_smallest_time(line, collision_points)

    def lines_contain_point(lines, point, amount_can_be_off_by):
        """returns: boolean; if all the lines contain the point (or are off by <= amount_can_be_off_by)"""

        return_value = True

        for line in lines:
            if not line.contains_point(point, amount_can_be_off_by):
                return_value = False
        return return_value

    def is_path_collision(path1: Path, path2: Path):
        """returns: boolean; if the two paths have collided"""

        path1_lines = path1.get_lines()
        path2_lines = path2.get_lines()
        return_value = False

        for line1 in path1_lines:
            for line2 in path2_lines:
                collision_point = CollisionsUtilityFunctions.get_line_collision_point(line1, line2)

                if collision_point is not None:
                    return_value = True

        return time if time != float('inf') else -1

    def get_time_of_path_collision(path1: Path, path2: Path):
        """returns: double; the time that the two paths collide (None if they don't collide)"""

        time = float('inf')

        path1_lines = path1.get_lines()
        path2_lines = path2.get_lines()

        for line1 in path1_lines:
            for line2 in path2_lines:
                collision_point = CollisionsUtilityFunctions.get_line_collision_point(line1, line2)

                if collision_point is not None:
                    time1 = CollisionsUtilityFunctions.get_time_to_point(line1, collision_point)
                    time2 = CollisionsUtilityFunctions.get_time_to_point(line2, collision_point)
                    is_valid_time = is_within_range(time1, time2, .01)
                    # The time of the collision should be changed if the time is valid and it is less than the current time
                    time = time1 if is_valid_time and time1 < time else time

        return time if time != float('inf') else -1

    def get_time_to_point(line, point):
        """returns: double; the time it would take to reach that point and it returns -1 if the time it would take is
        greater than VelocityCalculator.time"""
        # Using distance formula d = sqrt((x1-x2)^2 + (y1-y2)^2)
        line_total_distance = sqrt(pow(line.start_point.x_coordinate - line.end_point.x_coordinate, 2)
                                   + pow(line.start_point.y_coordinate - line.end_point.y_coordinate, 2))

        distance_to_point = sqrt(pow(line.start_point.x_coordinate - point.x_coordinate, 2)
                                   + pow(line.start_point.y_coordinate - point.y_coordinate, 2))

        velocity = line_total_distance / VelocityCalculator.time

        time = distance_to_point / velocity
        return time if time <= VelocityCalculator.time else -1

    # Only works if both objects are moving! If they aren't this logic makes 0 sense
    # def get_line_collision_time(line1: LineSegment, line2: LineSegment):
    #     """returns: double; the time at which line1 and line2 collide (None if they don't collide)"""
    #
    #     # y_line1 = LineSegment(Point(0, line1.start_point.y_coordinate), Point(VelocityCalculator.time, line1.end_point.y_coordinate))
    #     # y_line2 = LineSegment(Point(0, line2.start_point.y_coordinate), Point(VelocityCalculator.time, line2.end_point.y_coordinate))
    #     # x_line1 = LineSegment(Point(0, line1.start_point.x_coordinate), Point(VelocityCalculator.time, line1.end_point.x_coordinate))
    #     # x_line2 = LineSegment(Point(0, line2.start_point.x_coordinate), Point(VelocityCalculator.time, line2.end_point.x_coordinate))
    #     #
    #     # x_time = CollisionsUtilityFunctions.get_line_collision_point(x_line1, x_line2)
    #     # y_time = CollisionsUtilityFunctions.get_line_collision_point(y_line1, y_line2)
    #     collision_point = CollisionsUtilityFunctions.get_line_collision_point(line1, line2)
    #
    #     if collision_point is None:
    #         return -1
    #
    #     time1 = CollisionsUtilityFunctions.get_time_to_point(line1, collision_point)
    #     time2 = CollisionsUtilityFunctions.get_time_to_point(line2, collision_point)
    #
    #     # If the time where the x_time and y_time collide are roughly equal then they must have collided
    #     if time1 == -1 or time2 == -1:
    #         return -1
    #
    #     else:
    #         time1 = CollisionsUtilityFunctions.get_time_to_point(line1, collision_point)
    #         time2 = CollisionsUtilityFunctions.get_time_to_point(line2, collision_point)
    #         return time1 if is_within_range(time1, time2, .01) else -1

    def get_line_collision_point(line1, line2):
        """returns: Point; the point at which line1 and line2 collide (None if they don't collide)"""

        # If the lines are parallel they couldn't have collided
        if line1.slope == line2.slope:
            return None

        x_collision_point = (line2.y_intercept - line1.y_intercept) / (line1.slope - line2.slope)
        collision_point = Point(x_collision_point, line1.get_y_coordinate(x_collision_point))

        # If one of the line segments doesn't contain that collision point then the lines couldn't have collided
        if not line1.contains_point(collision_point, 1) or not line2.contains_point(collision_point, 1):
            collision_point = None

        return collision_point

    def is_line_collision(line1: LineSegment, line2: LineSegment):
        """returns: boolean; if the two lines have crossed"""

        return CollisionsUtilityFunctions.get_line_collision_point(line1, line2) is not None

    def get_path_line_collision_point(line: LineSegment, path: Path):
        """returns: Point; the x and y coordinate at which the line and path collide (None if they don't collide)"""

        collision_point = None

        for path_line in path.get_lines():
            collision_point = CollisionsUtilityFunctions.get_line_collision_point(path_line, line)

            if collision_point is not None:
                break

        return collision_point

    def get_bottommost_object(object1, object2):
        """ summary: finds the object whose y_coordinate is the biggest (top of the screen is 0)

              params:
                 object1: GameObject; one of the objects that is used to see if the two objects provided have collided
                 object2: GameObject; one of the objects that is used to see if the two objects provided have collided

              returns: GameObject; the object that is on the bottom of the screen
         """
        return object1 if object1.y_coordinate > object2.y_coordinate else object2

    def get_topmost_object(object1, object2):
        """ summary: finds the object whose y_coordinate is the smallest (top of the screen is 0)

             params:
                object1: GameObject; one of the objects that is used to see if the two objects provided have collided
                object2: GameObject; one of the objects that is used to see if the two objects provided have collided

             returns: GameObject; the object that is on the top of the screen
        """

        return object1 if object1.y_coordinate < object2.y_coordinate else object2

